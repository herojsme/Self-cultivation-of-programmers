## 如何对网站的文件和资源进行优化?

- 1.文件合并（目的是减少 http 请求）：使用 css sprites 合并图片，一个网站经常使用小图标和小图片进行美化，但是很遗憾这些小图片占用了大量的 HTTP 请求，因此可以采用 sprites 的方式把所有的图片合并成一张图片 ，可以通过相关工具在线合并，也可以在 ps 中合并。
- 2.使用 CDN（内容分发网络）加速，降低通信距离。
- 3.缓存的使用，添加 Expire/Cache-Control 头。
- 4.启用 Gzip 压缩文件
- 5.将 css 放在页面最上面。
- 6.将 script 放在页面最下面。
- 7.避免在 css 中使用表达式。
- 8.将 css, js 都放在外部文件中。
- 9.减少 DNS 查询。
- 10.文件压缩：最小化 css, js，减小文件体积。
- 11.避免重定向。
- 12.移除重复脚本。
- 13.配置实体标签 ETag。14.使用 AJAX 缓存，让网站内容分批加载，局部更新。

# 移动端性能如何优化？

- 尽量使用 CSS3 动画，开启硬件加速。
- 适当使用 touch 事件代替 click 事件。
- 避免使用 CSS3 渐变阴影效果。
- 可以用 transform:translateZ（0）来开启硬件加速。
- 不滥用 Float, Float 在渲染时计算量比较大，尽量少使用。
- 不滥用 Web 字体，Web 字体需要下载、解析、重绘当前页面，尽量少使用。
- 合理使用 requestAnimation Frame 动画代替 setTimeout。
- 合理使用 CSS 中的属性（CSS3 transitions、CSS3 3D transforms、 Opacity、 Canvas、 WebGL、Video）触发 GPU 渲染。过度使用会使手机耗电量増加。

# 如何分析并对代码进行性能优化 ？

利用性能分析工具监测性能，包括静态 Analyze 工具和运行时的 Profile 工具（在 Xcode 工具栏中依次单击 Product→ Profile 项可以启动）。

比如测试程序的运行时间，当单击 Time Profiler 项时，应用程序开始运行，这就能获取到运行整个应用程序所消耗时间的分布和百分比。为了保证数据分析在同一使用场景下的真实性，一定要使用真机，因为此时模拟器在 Mac 上运行，而 Mac 上的 CPU 往往比 iOS 设备要快

# 浏览器缓存机制 ？

浏览器缓存是比较常见的问题，我会从浏览器缓存的方式，缓存的实现， 缓存在哪里这几个点来说明
缓存方式
我们经常说的浏览器缓存有两种，一种是强制缓存，一种是协商缓存，因为下面有具体实现讲解，所以这里就说一下概念
协商缓存协商缓存意思是文件已经被缓存了，但是否从缓存中读取是需要和服务器进行协商，具体如何协商要看请求头/响应头的字段设置，下面会说到。需要注意的是协商缓存还是发了请求的
强制缓存强制缓存就是文件直接从缓存中获取，不需要发送请求
缓存实现
强制缓存
强制缓存在 http1.0 的时候用的是 Expires，是响应头里面的一个字段表示的是文件过期时间。是一个绝对时间，正因为是绝对时间所以在某些情况下，服务器的时区和浏览器时区不一致的时候就会导致缓存失效。为了解决这个问题，HTPP1.1 引入了一个新的响应头 cache-control 它的可选值如下
cache-control
max-age: 缓存过期时间，是一个相对时间
public: 表示客户端和代理服务器都会缓存
private: 表示只在客户端缓存
no-cache: 协商缓存标识符，表示文件会被缓存但是需要和服务器协商
no-store: 表示文件不会被缓存
HTTP1.1 利用的就是 max-age:600 来强制缓存，因为是相对时间，所以不会出现 Expires 问题
协商缓存协商缓存是利用 Last-Modified/if-Modified-Since,Etag/if-None-Match 这两对请求、响应头。Last-Modified/if-Modified-SinceEtag/If-None-Match 由于 Last-Modified 的时间粒度是秒，有的文件在 1s 内可能被改动多次。这种方式在这种特殊情况下还是会失效，所以 HTTP1.1 又引入了 Etag 字段。这个字段是根据文件内容生成一个标记符比如"W/"5f9583bd-10a8""，然后再和 If-None-Match 进行对比就能更准确的知道文件有没有被改动过
浏览器第一次发送请求获取文件缓存下来，服务器响应头返回一个 if-Modified-Since，记录被改动的时间
浏览器第二次发送请求的时候会带上一个 Last-Modified 请求头，时间就是 if-Modified-Since 返回的值。然后服务器拿到这个字段和自己内部设置的时间进行对比，时间相同表示没有修改，就直接返回 304 从缓存里面获取文件
缓存在哪里
知道了缓存方式和实现，再来说一下缓存存在哪个地方，我们打开掘金可以看到如下的信息 。缓存的来源有两个地方 from dist cache,from memeory cache
form memory cache
这个是缓存在内存里面，优点是快速，但是具有时效性，当关闭 tab 时候缓存就会失效。
from dist cache
这个是缓存在磁盘里面，虽然慢但是还是比请求快，优点是缓存可以一直被保留，即使关闭 tab 页，也会一直存在
何时缓存在 memory,合适缓存在 dist？
这个问题网上很少找的到标准答案，大家一致的说法是 js,图片文件浏览器会自动保存在 memory 中，css 文件因为不常修改保存在 dist 里面，我们可以打开掘金网站，很大一部分文件都是按照这个规则来的，但是也有少数 js 文件也是缓存在 dist 里面。所以他的存放机制到底是什么样了？我带着这个疑问查了好多文章，虽然最后没有确切找到答案，但是一个知乎的回答可以给我们提供思路，下面引用一个知乎回答者一段话
第一个现象(以图片为例)：访问-> 200 -> 退出浏览器再进来-> 200(from disk cache) -> 刷新 -> 200(from memory cache)。总结: 会不会是 chrome 很聪明的判断既然已经从 disk 拿来了， 第二次就内存拿吧 快。（笑哭)
第二个现象(以图片为例)：只要图片是 base64 我看都是 from memroy cache。总结: 解析渲染图片这么费劲的事情，还是做一次然后放到内存吧。用的时候直接拿
第三个现象(以 js css 为例)：个人在做静态测试的发现，大型的 js css 文件都是直接 disk cache。结: chrome 会不会说 我去 你这么大太占地方了。你就去硬盘里呆着吧。慢就慢点吧。
第四个现象：隐私模式下，几乎都是 from memroy cache。总结: 隐私模式 是吧。我不能暴露你东西，还是放到内存吧。你关，我死。
上面几点是虽然很幽默，但是却可以从中找到一部分答案，但是我觉得另一个知乎回答我更赞同
浏览器运行的时候也是由几个进程协作的，所以操作系统为了节省内存，会把一部分内存里的资源交换回磁盘的交换区，当然交换是有策略的，比如最常用的就是 LRU。
什么时候存 dist，什么时候存 memoey 都是在浏览器控制下的，memory 不够了可能就会考虑去存 dist 了，所以经过上面所说我自己总结结果如下
大一点的文件会缓存在 dist 里面，因为内存也是有限的，磁盘的空间更大
小一点文件 js,图片存的是 memory
css 文件一般存在 dist
特殊情况 memory 大小是有限制的，浏览器也会根据自己的内置算法，把一部分 js 文件存到 dist 里面

# 如何进行前端渲染优化 ？

1、设置 viewport:HTML 的 viewport 可加速页面的渲染

2、减少 DOM 节点：DOM 节点太多影响页面的渲染，尽量减少 DOM 节点。

3、优化动画
（1）：尽量使用 css3 动画
（2）：合理使用 requestAnimationFrame 动画代替 setTimeout.
（3）：适当使用 canvas 动画：5 个元素以内使用 css 动画，5 个元素使用 canvas 动画，iOS8+可使用 WebGL 动画。

4、优化高频事件：scroll、touchmove 等事件可导致多次渲染。
（1）：函数节流
（2）：函数防抖
（3）：使用 requestAnimationFrame 监听帧变化：使得在正确的时间进行渲染
（4）：增加响应变化的时间间隔：减少重绘次数

5、GPU 加速:使用某些 html5 标签和 css3 属性触发 GPU 渲染，请合理使用(过渡使用会引发手机耗电量增加)。
（1）：html 标签：video,canvas，webgl
（2）：css 属性，opacity,transform，transition
