### ref 访问底层 DOM 元素或组件

```js
      <input ref="input">
      <Child ref="child" />
```

### 组件：

```js
      - 数据props:
        + 组合式中使用 defineProps，
        + 选项式 props
      - 事件：
        + 组合式中使用 defineEmits
        + 选项式 emits
        + 子组件可以通过$emit(mothodName)抛出一个事件

      - 内部状态
        + 组合式：
            ref(),在函数内要用.value属性，模板中直接使用
            reactive() 与ref()区别 ，reactive将使对象本身具有响应性，适合对象类型不适合原始类型，而且不用.value
        + 选项式：
            data() 可通过 this.$data 访问该响应式对象
        + 响应式工具函数：
          isRef()
      - 计算属性  computed
      - 侦听器    watch
          watch(
              source,
              (newValue, oldValue) => {},
            可选 {
                  immediate: true 强制侦听器的回调立即执行
                  once: true 变化时，仅触发一次
              }
          )
          watchEffect()消除手动维护依赖列表的负担,只跟踪回调中被使用到的属性;可以用返回函数停止
      - v-modal:
          // 子组件：
          const model = defineModel({ default: 1 })

          // 父组件
          const myRef = ref()
          <Child v-model="myRef"></Child>
      - Attributes
        默认透传， 可通过defineOptions禁用
```

### 组件进阶

```js
  - 组件注册：
    + 全局用app.compenent(ComponentName)
    + 组合式直接引入
    + 选项式用components属性
  - 对外暴漏：
    + 组合式： defineExpose
  - 插槽:
    + 父组件用<slot/>标签，多个则为<slot name="a"/>
    + 子组件用<template/>标签，多个则为<template v-slot:a>/<template #header>,子组件支持动态插槽名称
    + 插槽作用域，父组件通过props给子组件传递值，子组件可以通过v-slot的表达式访问到
  - 异步组件：defineAsyncComponent，加载与错误状态自行设置，搭配 Suspense 使用

  - 复用或提取公有逻辑：
    + 依赖注入
      - provide 树根节点
      - inject   任意子节点，可以访问到上面提供的数据
    + 插件：
        插件是一个函数或者含有install的对象
        app.use(myPlugin, {/* 可选的选项 */})
    + mixins、extends
    + 自定义指令
    + 组合式函数
    + pina：
      - store
      - getter
      - aciton
        export const useCounterStore = defineStore('counter', {
          state: () => ({
            count: 0,
          }),
          getters: {
            // 自动推断出返回类型是一个 number
            doubleCount(state) {
              return state.count * 2
            },
            // 返回类型**必须**明确设置
            doublePlusOne(): number {
              // 整个 store 的 自动补全和类型标注 ✨
              return this.doubleCount + 1
            },
          },
          actions: {
            increment() {
              this.count++
            },
            randomizeCounter() {
              this.count = Math.round(100 * Math.random())
            },
          },
        })
        <script setup>
          import { useCounterStore } from './counterStore'
          const store = useCounterStore()
        </script>
        <template>
          <p>Double count is {{ store.doubleCount }}</p>
          <button @click="store.increment()">Randomize</button>
        </template>
```

### Vue Router

```js
模式：history模式 hash模式

<router-link to="/">Go to Home</router-link>
<router-link to="/about">Go to About</router-link>

导航方式：push replace  go

 选项式：this.$router
 组合式：useRouter

 动态路由：this.$route.params
 路由匹配语法：
 嵌套路由：
 路由懒加载：动态导入

 路由守卫：
 - 导航被触发。
 - 在失活的组件里调用 beforeRouteLeave 守卫。
 - 调用全局的 beforeEach 守卫。
 - 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。
 - 在路由配置里调用 beforeEnter。
 - 解析异步路由组件。
 - 在被激活的组件里调用 beforeRouteEnter。
 - 调用全局的 beforeResolve 守卫(2.5+)。
 - 导航被确认。
 - 调用全局的 afterEach 钩子。
 - 触发 DOM 更新。
 - 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。
```
