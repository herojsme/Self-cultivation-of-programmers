### 单页面应用（SPA）多页面（MPA）

```text
    单页面应用(Single-Page application)
    通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。

    多页面（MPA）
    指一个应用中有多个页面，页面跳转时是整页刷新


    单页面的优点：
    用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。

    单页面缺点：
    不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多
```

### 文件基本写法

```js
        <template>
            <div class="example">{{ msg }}</div>
        </template>

        <script>
            export default {
                data() {
                    return {
                        msg: 'Hello world!'
                    }
                }
            }
        </script>

        <style>
            .example {
            color: red;
            }
        </style>

        <custom1>
            This could be e.g. documentation for the component.
        </custom1>

     单文件组件 (SFC)，*.vue 作为文件扩展名，三种顶层语言块： <template>、<script>、<style>以及一些其他的自定义块
        <template>：最顶层只能有一个，变量双大括号语法 mustache
        <script>最顶层也是一个(<script setup>除外)
        <style>可以包含多个，每个可以有scoped活module attribute
        自定义块：第三方包的如<i18n>或自定义的块
```

### 递归组件自引用

```js
    一个名为 FooBar.vue 的组件可以<FooBar/> 引用自己
```

### 动态组件

```js
    <script setup>
        import Foo from './Foo.vue'
        import Bar from './Bar.vue'
    </script>
    <template>
    <component :is="Foo" />
    <component :is="someCondition ? Foo : Bar" />
    </template>
```

### css 功能

```js
    <style scoped>
        scoped限制样式在当前组件中使用
        .example {
            color: red;
        }
        深度选择器 可以更深影响到子组件
        .child :deep(.b){
            color: red;
        }
        插槽选择器 :slotted
        :slotted(div) {
        color: red;
        }
        全局选择器
        :global(.red) {
            color: red;
        }
    </style>
    可以混用 <style> <style scoped>


    Class与style
```

### cssModules

```js
    // CSS class 作为 $style 对象暴露给组件
    <template>
        <p :class="$style.red">This should be red</p>
    </template>

    <style module>
        .red {
            color: red;
        }
    </style>

    module attribute还可以自定义名字，如为<style module='a'>，组件引用就<p :class="a.red">
    组合式 API用useCssModule实现

    // css中可以支持v-bind css函授将值链接到动态状态值
    <template>
        <p>hello</p>
    </template>
    <script setup>
        const theme = {
            color: 'red'
        }
    </script>
    <style scoped>
        p {
            color: v-bind('theme.color');
        }
    </style>
```

### 生命周期函数

```js
        渲染时
            beforeCreate
            created
            含有预编译模版
                beforeMount  组合式onBeforeMount
                mounted     组合式onMounted
        重绘时
            beforeUpdate    组合式 onBeforeUpdate
            updated         组合式onUpdated
        销毁时
            beforeUnmount   组合式onBeforeMount
            unmounted       组合式onUnmounted

            errorCaptured   组合式onErrorCaptured
    <KeepAlive>   特有
        组件被移除时
            deactivated     组合式onDeactivated
        组件插入dom时
            activated       组合式onActivated
    服务端渲染
        渲染之前
            serverPrefetch  组合式onServerPrefetch


    简述Vue 子组件和父组件执行顺序 ？
        加载渲染过程：
            1.父组件 beforeCreate
            2.父组件 created
            3.父组件 beforeMount
                4.子组件 beforeCreate
                5.子组件 created
                6.子组件 beforeMount
                7.子组件 mounted
            8.父组件 mounted
        更新过程：
            1. 父组件 beforeUpdate
                2.子组件 beforeUpdate
                3.子组件 updated
            4.父组件 updated
        销毁过程：
            1. 父组件 beforeDestroy
                2.子组件 beforeDestroy
                3.子组件 destroyed
            4.父组件 destorye
```

### 内置组件

```js
<Transition> 单个元素或组件提供动画过渡效果
<TransitionGroup> 为列表中的多个元素或组件提供过渡效果
<KeepAlive> 缓存包裹在其中的动态切换组件
<Teleport> 将其插槽内容渲染到 DOM 中的另一个位置
<Suspense> 对组件树中嵌套的异步依赖的处理
```

### 内置特殊元素

```js
<component> Props is: string | Component
<slot> 可用 name 属性指定名称
<template> 顶层标签中的<template>不支持指令，其他支持 v-if v-else-if v-else v-for v-slot key 值
```

### 两种写法：选项式、组合式

```js
        // 选项式
        <script>
            export default {
                data() {
                    return {
                        msg: 'Hello world!'
                    }
                }
            }
        </script>

        // 组合式  setup   配合响应式api使用
        <script setup>
            import { ref } from 'vue'；
            const msg=ref(Hello world!')
        </script>
        // 在非单文件或选项式中使用组合式时，可以使用setup()
        <script>
            import { ref } from 'vue'；
            export default {
                setup() {
                    const msg=ref(Hello world!')
                    return {
                        msg
                    }
                }
            }
        </script>



        顶层的绑定会被暴露给模板

        优点：
            1 更少的样板内容，更简洁的代码
            2 能够使用纯 TypeScript 声明 props 和自定义事件。
            3 其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象，性能会提升
            4 减少了语言服务器从代码中抽取类型的工作，更好的 IDE 类型推导性能
```
